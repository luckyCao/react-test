{"version":3,"sources":["promise.js"],"names":[],"mappings":"AAAA,MAAM,UAAY,CAAlB;AACA,MAAM,YAAY,CAAlB;AACA,MAAM,WAAY,CAAlB;AACA,SAAS,OAAT,CAAiB,EAAjB,EAAoB;AAChB,QAAI,QAAQ,OAAZ;AAAA,QACI,QAAQ,IADZ;AAAA,QAEI,WAAW,EAFf;AAGA,aAAS,MAAT,CAAgB,GAAhB,EAAoB;AAChB,YAAG,UAAU,OAAb,EAAqB;AACjB,qBAAS,IAAT,CAAc,GAAd;AACH;AACD,YAAG,SAAS,SAAZ,EAAsB;AAClB,gBAAI,WAAJ,CAAgB,KAAhB;AACH;AACD,YAAG,SAAS,QAAZ,EAAqB;AACjB,gBAAI,UAAJ,CAAe,KAAf;AACH;AACJ;AACD,aAAS,OAAT,CAAiB,GAAjB,EAAqB;AACjB,gBAAQ,SAAR;AACA,gBAAQ,GAAR;AACA,iBAAS,GAAT,CAAa,WAAS;AAClB,mBAAO,OAAP;AACH,SAFD;AAGH;AACD;AACA,aAAS,OAAT,CAAiB,GAAjB,EAAqB;AACjB,YAAG,CAAC,GAAJ,EAAQ;AACJ;AACH;AACD,YAAI,OAAO,QAAQ,GAAR,CAAX;AACA;AACA,YAAG,IAAH,EAAQ;AACJ;AACA,iBAAK,IAAL,CAAU,GAAV,EAAe,KAAD,IAAS;AAAC;AACpB,wBAAQ,KAAR,EADmB,CACJ;AAClB,aAFD,EAEE,MAAI,CAAE,CAFR;AAGH,SALD,MAMI;AACA,oBAAQ,GAAR;AACH;AACJ;AACD,aAAS,OAAT,CAAiB,GAAjB,EAAqB;AACjB,eAAO,IAAI,IAAJ,GAAS,IAAI,IAAb,GAAkB,IAAzB;AACH;AACD,aAAS,MAAT,CAAgB,GAAhB,EAAoB;AAChB,gBAAQ,QAAR;AACA,gBAAQ,GAAR;AACA,iBAAS,GAAT,CAAa,WAAS;AAClB,mBAAO,OAAP;AACH,SAFD;AAGH;AACD,aAAS,SAAT,CAAmB,EAAnB,EAAsB,OAAtB,EAA8B,MAA9B,EAAqC;AACjC,WAAG,OAAH,EAAW,MAAX;AACH;AACD,SAAK,IAAL,GAAY,UAAS,WAAT,EAAqB,UAArB,EAAgC;AACxC,eAAO;AACH,yBAAY,WADT;AAEH,wBAAW;AAFR,SAAP;AAIH,KALD;AAMA,SAAK,IAAL,GAAY,UAAS,WAAT,EAAqB,UAArB,EAAgC;AACxC,YAAI,OAAO,IAAX;AACA,eAAO,IAAI,OAAJ,CAAY,CAAC,OAAD,EAAS,MAAT,KAAkB;AACjC,iBAAK,IAAL,CAAW,KAAD,IAAS;AAAC;AAChB,wBAAQ,YAAY,KAAZ,CAAR;AACA;AACH,aAHD,EAGE,MAAI,CAAE,CAHR;AAIH,SALM,CAAP;AAMH,KARD;AASA,cAAU,EAAV,EAAa,OAAb,EAAqB,MAArB;AACH;AACD,eAAe,OAAf;;AAEA,IAAI,UAAU,IAAI,OAAJ,CAAY,CAAC,OAAD,EAAS,MAAT,KAAkB;AACxC;AACA,eAAY,KAAD,IAAS;AAChB;AACA,gBAAQ,EAAR;AACH,KAHD,EAGE,IAHF;AAIH,CANa,CAAd;AAOA;AACA,QAAQ,IAAR,CAAc,KAAD,IAAS;AAClB;AACA,YAAQ,GAAR,CAAY,KAAZ;AACA;AACA,WAAO,IAAI,OAAJ,CAAY,CAAC,OAAD,EAAS,MAAT,KAAkB;AACjC,mBAAY,KAAD,IAAS;AAChB,oBAAQ,EAAR,EADgB,CACL;AACd,SAFD,EAEE,IAFF;AAGH,KAJM,CAAP;AAKH,CATD,EASE,MAAI,CAAE,CATR,EASU,IATV,CASe,SAAO;AAAE;AACpB,YAAQ,GAAR,CAAY,KAAZ,EADkB,CACA;AACrB,CAXD","file":"promise-compiled.js","sourcesContent":["const PENDING   = 0;\nconst FULFILLED = 1;\nconst REJECTED  = 2;\nfunction Promise(fn){\n    let state = PENDING,\n        value = null,\n        handlers = [];\n    function handle(obj){\n        if(state === PENDING){\n            handlers.push(obj)\n        }\n        if(state == FULFILLED){\n            obj.onFulfilled(value);\n        }\n        if(state == REJECTED){\n            obj.onRejected(value);\n        }\n    }\n    function fulfill(val){\n        state = FULFILLED;\n        value = val;\n        handlers.map(handler=>{\n            handle(handler)\n        })\n    }\n    //第三布的关键就在resolve\n    function resolve(val){\n        if(!val){\n            return;\n        }\n        let then = getThen(val);\n        //当onfulfilled返回的是promise的情况\n        if(then){\n            //(8)这里的作用域是p2,而这个then是p4的,val就是p4,p4的then方法被调用\n            then.call(val,(value)=>{//(10)p4的onFulfilled方法被调用\n                fulfill(value);//(11)p2的fulfill被执行(这里是关键，这里的fulfill的作用域是p2)\n            },()=>{})\n        }\n        else{\n            fulfill(val);\n        }\n    }\n    function getThen(val){\n        return val.then?val.then:null;\n    }\n    function reject(val){\n        state = REJECTED;\n        value = val;\n        handlers.map(handler=>{\n            handle(handler)\n        })\n    }\n    function doResolve(fn,fulfill,reject){\n        fn(fulfill,reject)\n    }\n    this.done = function(onFulfilled,onRejected){\n        handle({\n            onFulfilled:onFulfilled,\n            onRejected:onRejected\n        })\n    }\n    this.then = function(onFulfilled,onRejected){\n        var self = this;\n        return new Promise((resolve,reject)=>{\n            self.done((value)=>{//(2)\n                resolve(onFulfilled(value))\n                //(7)p1相应的onFulfilled函数返回了p4,并进入p2的resolve方法\n            },()=>{})\n        })\n    }\n    doResolve(fn,resolve,reject)\n}\nexport default Promise\n\nlet promise = new Promise((resolve,reject)=>{\n    //(1)这里创建了一个promise对象记为(p1)\n    setTimeout((value)=>{\n        //(4)一秒钟后p1的resolve(10)被执行\n        resolve(10)\n    },1000)\n})\n//(2)这里p1的then函数创建了一个promise对象p2\npromise.then((value)=>{\n    //(5)因为p1的resolve被执行所以p1相应的onFulfilled函数被执行打印了log 10\n    console.log(value);\n    //(6)接下来新建了一个promise对象(记为p4)，重点是这个对象返回了\n    return new Promise((resolve,reject)=>{\n        setTimeout((value)=>{\n            resolve(20)//(9)再一秒之后p4的resolve被执行\n        },1000)\n    });\n},()=>{}).then(value=>{ //(3)这是p2的then函数,它创建创建了一个promise对象p3\n    console.log(value)//(12)打印log 20\n})"]}